# disassemble_unpacked_pe.py
#
# Performs two functions:
# 1. Generates of list of unpacked PE binary files for input to the second function.
# 2. Reads a list of unpacked PE files and uses objdump to extract PE header 
#    information from each binary then uses IDA Pro to generate an assembler code
#    file of the binary.
#
# Input : unpacked_file_list.txt
#
# or
#
# Input : sorted-packer-id-features.csv
#         entry format = [file_name]
#                        [packer_name]
#                        [packer_id]
#                        [valid_pe]
#                        [is_packed]
#
# Output: assembler files [input_binary_filename.asm]
#
# or
#
# Output: unpacked_file_list.txt
#
# Author: Derek Chadwick
# Date  : 12/08/2016


from optparse import OptionParser
import subprocess as sub
import os
import sys
import pandas as pd



def write_unpacked_file_list(packer_id_feature_file, unpacked_list_file_name):
    # Load the malware packer id features sets from the sample set.
    packer_id_features = pd.read_csv(packer_id_feature_file)
    unpacked_files = packer_id_features[packer_id_features['is_packed'] == 0]
    unpacked_pe_files = unpacked_files[unpacked_files['valid_pe'] == 1]
    
    fop = open(unpacked_list_file_name, 'w')
    counter = 0
    
    for file_name in unpacked_pe_files['file_name']:
        full_name = "VirusShare_" + file_name + "\n"
        fop.write(full_name)
        counter += 1

    print("Write {:d} filenames.".format(counter))

    fop.close()
    
    return


def disassemble_pe_binaries(file_list, ext_drive):
    # Can use the command "objdump -D file_name -o file_name.asm" to dump out all 
    # sections of the PE binary and generate assembly code.
    # However the objdump output is not optimal for machine learning objectives, 
    # as we need to translate call operand target addresses to function names, 
    # A better alternative is to use IDA Pro in batch mode to generate the
    # assembly code.
    #
    # NOTE: IDA Pro Demo does not save any output, IDA Pro Free has a
    #       popup window on startup that prevents batch processing mode.
    #
    
    counter = 0
    disassed = 0
    error_count = 0
    command_line = ""
    
    for file_name in file_list:
        file_name = file_name.rstrip() # remove the newlines or else !!!
        file_path = ext_drive + file_name
        asm_file_name = "/opt/vs/asm/" + file_name + ".asm"
        hdr_file_name = "/opt/vs/asm/" + file_name + ".txt"
            
        if (os.path.isfile(file_path)):
            
            #command_line = "objdump -d {:s} > {:s}".format(file_path1, asm_file_name)
            #sub.call(["rasm2", "-d", "-a", "x86", "-s", "intel", "-f", file_path, "-O", asm_file_name])
            #sub.call(["./idaq69", "-B", file_path])
            #sub.call(["python", "vivisect", "-B", file_path])
            #sub.call(["objdump", "-g", "-x", "-D", "-s", "-t", "-T", "-M", "intel", file_path], stdout=fop)
            
            # Dump the assembly code listing.
            sub.call(["wine", '/opt/vs/ida/idag.exe', "-B", "-P+", file_path])
            
            # Dump section headers and import tables.
            fop = open(hdr_file_name, "w")
            sub.call(["objdump", "-g", "-x", file_path], stdout=fop)
            fop.close()
            
            # now delete the binary, we do not need it anymore.
            # sub.call(["rm", file_path1])
            
            disassed += 1

        else:
            #print("Error: file does not exist - {:s}".format(file_path))
            error_count += 1
           
        counter += 1
        if (counter % 1) == 0: # print progress
            print('Disassembled: {:d} - {:s}'.format(counter, file_name))    
 

    print("Disassembled {:d} binaries with {:d} file path errors.".format(disassed, error_count))
    
    #sub.call(["mv", "*.asm", "/opt/vs/asm"])
    
    return


# Start of Script


parser = OptionParser()
parser.add_option("-w", "--writelist", action="store_true", dest="writefilelist", default=False)
parser.add_option("-i", "--inputfile", dest="inputfilename")
parser.add_option("-o", "--outputfile", dest="outputfilename")
parser.add_option("-f", "--featurefile", dest="featurefilename")
parser.add_option("-e", "--extdrive", dest="externaldrive")

(options, args) = parser.parse_args()

# TODO: add code for options

# Load the malware packer id features sets.
ext_drive = options.externaldrive
feature_file = options.featurefilename
in_unpacked_file_list = options.inputfilename
out_unpacked_file_list = options.outputfilename
write_file_list = options.writefilelist

if write_file_list == True:
    write_unpacked_file_list(feature_file, out_unpacked_file_list)
elif in_unpacked_file_list != None:
    fip = open(in_unpacked_file_list)
    file_list = fip.readlines()
    disassemble_pe_binaries(file_list, ext_drive)
    fip.close()
else:
    file_list = os.listdir(ext_drive)
    disassemble_pe_binaries(file_list, ext_drive)
    

# End of Script
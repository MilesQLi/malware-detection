# feature_extraction_pe_asm.py
#
# Read a list of PE ASM files generated by IDA Pro and section headers dumped
# by objdump and extract feature sets from them.
#
# Input : List of ASM code files generated by IDA Pro or objdump.
#
# Output: sorted-pe-asm-features.csv
#         row format = [file_name, [list of x86 opcodes], [list of x86 registers]]
#
#
#
# Author: Derek Chadwick
# Date  : 05/09/2016
#
# TODO: optimise and many many things

from multiprocessing import Pool
import os
from csv import writer
import numpy as np
import pandas as pd
import math
import scipy.misc
import array
import time as tm
import re
import subprocess as sub


keywords = ['Virtual','Offset','loc','Import','Imports','var','Forwarder','UINT','LONG'
            ,'BOOL','WORD','BYTES','large','short','dd','db','dw','XREF','ptr','DATA'
            ,'FUNCTION','extrn','byte','word','dword','char','DWORD','stdcall','arg'
            ,'locret','asc','align','WinMain','unk','cookie','off','nullsub','DllEntryPoint'
            ,'System32','dll','CHUNK','BASS','HMENU','DLL','LPWSTR','void','HRESULT','HDC'
            ,'LRESULT','HANDLE','HWND','LPSTR','int','HLOCAL','FARPROC','ATOM','HMODULE'
            ,'WPARAM','HGLOBAL','entry','rva','COLLAPSED','config','exe','Software'
            ,'CurrentVersion','__imp_','INT_PTR','UINT_PTR','---Seperator','PCCTL_CONTEXT'
            ,'__IMPORT_','INTERNET_STATUS_CALLBACK','.rdata:','.data:','.text:','case'
            ,'installdir','market','microsoft','policies','proc','scrollwindow','search'
            ,'trap','visualc','___security_cookie','assume','callvirtualalloc','exportedentry'
            ,'hardware','hkey_current_user','hkey_local_machine','sp-analysisfailed','unableto']

known_sections = ['.text', '.data', '.bss', '.rdata', '.edata', '.idata', '.rsrc', '.tls', '.reloc']

x86_registers = ['edx','esi','es','fs','ds','ss','gs','cs','ah','al',
                 'ax','bh','bl','bx','ch','cl','cx','dh','dl','dx',
                 'eax','ebp','ebx','ecx','edi','esp']

x86_opcodes = ['add','al','bt','call','cdq','cld','cli','cmc','cmp','const','cwd','daa','db'
                ,'dd','dec','dw','endp','ends','faddp','fchs','fdiv','fdivp','fdivr','fild'
                ,'fistp','fld','fstcw','fstcwimul','fstp','fword','fxch','imul','in','inc'
                ,'ins','int','jb','je','jg','jge','jl','jmp','jnb','jno','jnz','jo','jz'
                ,'lea','loope','mov','movzx','mul','near','neg','not','or','out','outs'
                ,'pop','popf','proc','push','pushf','rcl','rcr','rdtsc','rep','ret','retn'
                ,'rol','ror','sal','sar','sbb','scas','setb','setle','setnle','setnz'
                ,'setz','shl','shld','shr','sidt','stc','std','sti','stos','sub','test'
                ,'wait','xchg','xor']


def count_asm_symbols(asm_code):
    symbols = [0]*7
    for row in asm_code:
        if '*' in row:
            symbols[0] += 1
        if '-' in row:
            symbols[1] += 1
        if '+' in row:
            symbols[2] += 1
        if '[' in row:
            symbols[3] += 1
        if ']' in row:
            symbols[4] += 1
        if '@' in row:
            symbols[5] += 1
        if '?' in row:
            symbols[6] += 1

    return symbols


def count_asm_APIs(asm_code, apis):
    apis_values = [0]*len(apis)
    for row in asm_code:
        for i in range(len(apis)):
            if apis[i] in row:
                apis_values[i] += 1
                break
    return apis_values


def count_asm_misc(asm_code):
    keywords_values = [0]*len(keywords)
    for row in asm_code:
        for i in range(len(keywords)):
            if keywords[i] in row:
                keywords_values[i] += 1
                break
    return keywords_values


def count_asm_registers(asm_code):
    registers_values = [0]*len(x86_registers) # Need to optimise this init stuff to global vars.
    
    for row in asm_code:
        parts = row.replace(',',' ').replace('+',' ').replace('*',' ').replace('[',' ').replace(']',' ') \
                    .replace('-',' ').split()

        for idx, register in enumerate(x86_registers):
            registers_values[idx] += parts.count(register)

    return registers_values


def count_asm_opcodes(asm_code):
    opcodes_values = [0]*len(x86_opcodes)
    
    for row in asm_code:
        parts = row.split()

        for idx, opcode in enumerate(x86_opcodes):
            if opcode in parts:
                opcodes_values[idx] += 1
                break

    return opcodes_values


def extract_asm_features(multi_param):
    
    pid = os.getpid()
    feature_file = 'data/' + str(pid) + "-" + multi_param.temp_file
    print('Process id: {:d} feature file: {:s}'.format(pid,feature_file))

    # Do this in call graph feature extraction.
    #fapi = open("data/APIs.txt")
    #defined_apis = fapi.readlines()
    #defined_apis = defined_apis[0].split(',')

    asm_files = [i for i in tfiles if '.asm' in i]
    ftot = len(asm_files)
    
    feature_counts = []
    with open(feature_file, 'w') as f:
        
        fw = writer(f)
        
        for idx, fname in enumerate(asm_files):
            
            fasm = open(ext_drive + fname, 'r')
            content = fasm.readlines()
            fasm.close()
            
            fname = fname[fname.find("_")+1:] # Remove VirusShare_ from the start of the file name.
            
            reg_vals = count_asm_registers(content)
            opc_vals = count_asm_opcodes(content)
            #api_vals = count_asm_APIs(content, defined_apis) put in Call Graph features.
            #sec_vals = count_asm_sections(content) already in PE header features.
            #mis_vals = count_asm_misc(content) mostly already in PE header and call graph features.
            count_vals = reg_vals + opc_vals # + api_vals + mis_vals
            
            feature_counts.append([fname[:fname.find('.asm')]] + count_vals)   
            
            # Writing rows after every 10 files processed
            if (idx+1) % 10 == 0:
                print("{:d} {:d} of {:d} files processed.".format(pid, idx + 1, ftot))
                fw.writerows(feature_counts)
                feature_counts = []
                
        # Writing remaining files
        if len(feature_counts) > 0:
            fw.writerows(feature_counts)
            feature_counts = []

    return



def combine_asm_files(out_file, temp_file):
    # Function to combine the newly generated asm feature files into one file:
    # 1. list data directory
    # 2. For each file in file list that matches (\d\d\d\d-asm-features.csv)
    # 3. Trim the filenames if necessary (should remove VirusShare_  prefix).
    # 4. Concatenate the unsorted asm feature files.
    # 5. Sort and write to data/sorted-asm-features.csv
    
    fop = open('data/' + out_file,'w')
    colnames = "file_name," + ",".join(x86_registers) + "," + ",".join(x86_opcodes) + "\n"
    fop.write(colnames)
    
    print("Column names: {:s}".format(colnames))
    
    p1 = re.compile('\d{3,5}-' + temp_file) # This is the PID prefix for each file.
    file_list = os.listdir('data/')
    counter = 0
    
    for file_name in file_list:
        if p1.match(file_name):
            fip = open('data/' + file_name, 'r')
            in_lines = fip.readlines()
            fop.writelines(in_lines)
            counter += len(in_lines)
            fip.close()
            
    print('Completed combine of {:d} ASM features.'.format(counter))  
    
    fop.close()
    
    asms = pd.read_csv('data/' + out_file)
    # DataFrame.sort() is deprecated, but this is an old version of pandas, does not have sort_values().
    sorted_asms = asms.sort('file_name')
    sorted_asms.to_csv('data/sorted-' + out_file, index=False)
    sorted_asms.head(20)
    
    return


class Multi_Params(object):
    def __init__(self, featurefile="", tempfile="", filelist=[]):
        self.feature_file = featurefile
        self.temp_file = tempfile
        self.file_list = filelist


        
# Start of Script

# Divide the train files into four groups for multiprocessing.

# TODO: add command line arguments to specify file names.

#out_file = 'pe-asm-features-apt.csv'
#temp_file = 'pe-asm-temp-apt.csv'
#ext_drive = '/opt/vs/asm'

out_file = 'pe-asm-features-vs251.csv'
temp_file = 'pe-asm-temp-vs251.csv'

ext_drive = '/opt/vs/train1asm/'
tfiles = os.listdir(ext_drive)

quart = len(tfiles)/4
train1 = tfiles[:quart]
train2 = tfiles[quart:(2*quart)]
train3 = tfiles[(2*quart):(3*quart)]
train4 = tfiles[(3*quart):]

mp1 = Multi_Params(out_file, temp_file, train1)
mp2 = Multi_Params(out_file, temp_file, train2)
mp3 = Multi_Params(out_file, temp_file, train3)
mp4 = Multi_Params(out_file, temp_file, train4)

trains = [mp1, mp2, mp3, mp4]
p = Pool(4)
p.map(extract_asm_features, trains)


combine_asm_files(out_file, temp_file)

# End of Script
    
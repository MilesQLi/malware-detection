# disassemble_pe.py
#
# Performs two functions:
# 1. Generates of list of unpacked PE binary files for input to the second function.
# 2. Reads a list of unpacked PE files and uses objdump to extract PE header 
#    information from each binary then uses IDA Pro to generate an assembly code
#    file of the binary.
#
# Input : unpacked_file_list.txt
#
# or
#
# Input : sorted-packer-id-features.csv
#         row format = [file_name, packer_name, packer_id, valid_pe, is_packed]
#
#         sorted-file-id-features.csv
#         row format = [file_name, file_type, file_id]
#
#         sorted-trid-id-features.csv
#         row format = [file_name, file_type, percentage, file_id]
#
# Output: assembler files [input_binary_filename.asm]
#         PE header files [input_binary_filename.txt]
#
# or
#
# Output: unpacked_file_list.txt
#
# Author: Derek Chadwick
# Date  : 12/08/2016


from optparse import OptionParser
import subprocess as sub
import os
import sys
import pandas as pd



def write_unpacked_file_list(packer_id_feature_file, unpacked_list_file_name):
    # Load the malware packer id features sets from the sample set.
    packer_id_features = pd.read_csv(packer_id_feature_file)
    unpacked_files = packer_id_features[packer_id_features['is_packed'] == 0]
    unpacked_pe_files = unpacked_files[unpacked_files['valid_pe'] == 1]
    
    fop = open(unpacked_list_file_name, 'w')
    counter = 0
    
    for file_name in unpacked_pe_files['file_name']:
        full_name = "VirusShare_" + file_name + "\n"
        fop.write(full_name)
        counter += 1

    print("Wrote {:d} filenames.".format(counter))

    fop.close()
    
    return


def get_unpacked_file_list(packer_id_feature_file, file_id_feature_file, trid_id_feature_file):
    # Load the malware packer id features and file id features from the sample set.
    packer_id_features = pd.read_csv(packer_id_feature_file)
    file_id_features = pd.read_csv(file_id_feature_file)
    trid_id_features = pd.read_csv(trid_id_feature_file)
    
    # Get a list of unpacked PE files that are not .NET CIL format.
    # IDA Pro cannot disassemble .NET files.
    unpacked_files = packer_id_features[packer_id_features['is_packed'] == 0]
    unpacked_pe_files = unpacked_files[unpacked_files['valid_pe'] == 1]
    not_dot_net = []
    counter = 0
    dot_net_counter = 0
    
    # Get the trid and file rows that are for unpacked PE files.
    trids = trid_id_features[trid_id_features['file_name'].isin(unpacked_pe_files['file_name'])]
    fids = file_id_features[file_id_features['file_name'].isin(unpacked_pe_files['file_name'])]
    
    # Iterate over the unpacked PE file list and check if each is a .NET file.
    # If not a .NET file then add to file list.
    pe_names_list = unpacked_pe_files['file_name']
    for idx, file_name in enumerate(pe_names_list):
        trid_name = trids.iloc[idx, 1]
        fid_name = fids.iloc[idx, 1]
        trid_name = trid_name.lower()
        fid_name = fid_name.lower()
        
        if trid_name.find('.net') > -1 or fid_name.find('.net') > -1:
            print('Found: {:s} - {:s}'.format(trid_name, fid_name))
            dot_net_counter += 1
            continue
            
        #print('Found: {:s} - {:s}'.format(trid_name, fid_name))
        not_dot_net.append(file_name)
        counter += 1
    
    file_list = []
    counter = 0
    
    # Iterate over the file list and prepend the full file name.
    for file_name in not_dot_net:
        full_name = "VirusShare_" + file_name + "\n"
        file_list.append(full_name)
        counter += 1

        
    fop = open('data/unpacked-pe-non-dot-net.txt','w')
    fop.writelines(file_list)
    fop.close()
    
    print("Got {:d} unpacked PE filenames and {:d} .NET filenames.".format(counter, dot_net_counter))

    return file_list


def disassemble_pe_mem_dump(file_list):
    # Disassemble the unpacked memory segments dumped by the unpack tool.
    # 
    # TODO: everything    
    
    return


def disassemble_pe_binaries(file_list):
    # Can use the command "objdump -d file_name -o file_name.asm" to dump out all 
    # sections of the PE binary and generate assembly code.
    # However the objdump output is not optimal for machine learning objectives, 
    # as we need to translate call operand target addresses to function names, 
    # A better alternative is to use IDA Pro in batch mode to generate the
    # assembly code.
    #
    # NOTE: IDA Pro Demo does not save any output, IDA Pro Free has a
    #       popup window on startup that prevents batch processing mode.
    #
    
    counter = 0
    disassed = 0
    error_count = 0
    
    print("Disassembling {:d} binary PE files.".format(len(file_list)))
    
    for file_name in file_list:
        file_path = file_name.rstrip() # remove the newlines or else !!!
        asm_file_name = "/opt/vs/asm/" + file_name + ".asm"
        hdr_file_name = "/opt/vs/asm/" + file_name + ".txt"
            
        if (os.path.isfile(file_path)):
            
            #command_line = "objdump -d {:s} > {:s}".format(file_path1, asm_file_name)
            #sub.call(["rasm2", "-d", "-a", "x86", "-s", "intel", "-f", file_path, "-O", asm_file_name])
            #sub.call(["./idaq69", "-B", file_path])
            #sub.call(["python", "vivisect", "-B", file_path])
            #sub.call(["objdump", "-g", "-x", "-D", "-s", "-t", "-T", "-M", "intel", file_path], stdout=fop)
            
            # Dump the assembly code listing.
            sub.call(["wine", '/opt/vs/ida/idag.exe', "-B", "-P+", file_path])
            
            # Dump the PE section headers and import tables.
            fop = open(hdr_file_name, "w")
            sub.call(["objdump", "-g", "-x", file_path], stdout=fop)
            fop.close()
            
            # now delete the binary, we do not need it anymore.
            # sub.call(["rm", file_path1])
            
            disassed += 1

        else:
            #print("Error: file does not exist - {:s}".format(file_path))
            error_count += 1
           
        counter += 1
        if (counter % 1000) == 0: # print progress
            print('Disassembled: {:d} - {:s}'.format(counter, file_name))    
 

    print("Disassembled {:d} binaries with {:d} file path errors.".format(disassed, error_count))
    
    #sub.call(["mv", "*.asm", "/opt/vs/asm"])
    
    return


def run_processes(file_list):
    # Spawn worker processes.
    
    quart = len(file_list)/4
    train1 = tfiles[:quart]
    train2 = tfiles[quart:(2*quart)]
    train3 = tfiles[(2*quart):(3*quart)]
    train4 = tfiles[(3*quart):]

    print("Files: {:d} - {:d} - {:d}".format(len(tfiles), quart, (len(train1)+len(train2)+len(train3)+len(train4))))

    trains = [train1, train2, train3, train4]
    p = Pool(4)
    p.map(disassemble_pe_binaries, trains)
    
    return

def print_help():
    print("disassemble_pe -efhiow [input_file_list.txt]")
    print("    -e /path/to/sample/binaries/")
    print("    -f /path/to/file/id/feature/file")
    
    return


# Start of Script


parser = OptionParser()
parser.add_option("-w", "--writelist", action="store_true", dest="writefilelist", default=False)
parser.add_option("-i", "--inputfile", dest="inputfilename")
parser.add_option("-o", "--outputfile", dest="outputfilename")
parser.add_option("-f", "--fileidfeature", dest="featurefilename")
parser.add_option("-p", "--packeridfeature", dest="packerfilename")
parser.add_option("-t", "--trididfeature", dest="tridfilname")
parser.add_option("-e", "--extdrive", dest="externaldrive")
parser.add_option("-h", "--help", action="store_true", dest="printhelp", default=False)

(options, args) = parser.parse_args()

# TODO: add code for options

# Load the malware packer id features sets.
ext_drive = options.externaldrive
feature_file = options.featurefilename
in_unpacked_file_list = options.inputfilename
out_unpacked_file_list = options.outputfilename
write_file_list = options.writefilelist
print_help = options.printhelp

if print_help == True:
    print_help()
    sys.exit(0)
    

if write_file_list == True:
    # Generate a list of upacked PE binaries.
    write_unpacked_file_list(feature_file, out_unpacked_file_list)


if ext_drive != None:
    #ext_drive = '/opt/vs/train1/'
    #ext_drive = '/opt/vs/train2/'
    #ext_drive = '/opt/vs/train3/'
    #ext_drive = '/opt/vs/train4/'
    #ext_drive = '/opt/vs/apt/'


    # Read the list of unpacked PE files and disassemble.
    if in_unpacked_file_list != None:
        
        fip = open(in_unpacked_file_list)
        file_list = fip.readlines()
        fip.close()
        
        for idx, fname in file_list:
            file_list[idx] = ext_drive + fname
        
        run_processes(file_list)
        
    else:

        # Just get a list of files from the input directory and disassemble.
        tfiles = os.listdir(ext_drive)
        
        for idx, fname in tfiles:
            tfiles[idx] = ext_drive + fname

        run_processes(tfiles)

else:
    
    # If no command line options.
    packer_id_file = 'data/sorted-packer-id-features-vs251.csv'
    file_id_file = 'data/sorted-file-id-features-vs251.csv'
    trid_id_file = 'data/sorted-trid-id-features-vs251.csv'
    
    unflist = get_unpacked_file_list(packer_id_file, file_id_file, trid_id_file)
    
    run_processes(unflist)
    

# End of Script
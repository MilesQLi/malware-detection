# Run all the feature extraction functions:
#    1. Generate packer id values for PE files.
#    2. Generate file id values for all files.
#    3. Calculate entropy and file size for all files.
#    4. Disassemble upacked PE files.
#    5. Generate PE header information.
#    6. Extract ASM feature set.
#    7. Generate call graphs.
#    8. Calculate sample statistics.
#
#    Also includes several functions for generating
#    keywords/tokens from the ASM/header file
#    dumps and other text files such as scripts:
#
#    1. LibC API function list.
#    2. PE Header sections/imports.
#    3. ELF Header sections/imports.
#    4. x86 instruction set.
#    5. amd64 instruction set.
#    6. Javascript keywords.
#    7. Java bytecode keywords.
#    8. PDF sections/keywords.
#    9. HTML tags.
#    10. Visual Basic Script keywords.
#    11. Powershell Script keywords.
#    12. Microsoft Word document keywords.
#
#
# Author: Derek Chadwick
# Date  : 04/08/2016



from multiprocessing import Pool
import os
import peutils
import pefile
import sys
import re
import numpy as np
import pandas as pd
import subprocess as sub



# Local modules
# import feature_extraction_packer_id as fepi
# import feature_extraction_file_id as fefi
# import feature_extraction_entropy as feet
# import feature_extraction_elf_asm as felf
# import feature_extraction_pe_asm as fasm



def generate_libc_api():
    # Extract libc function and variable names from GNU Libc Documentation.
    # Put in feature_extraction.py
    
    fipfunc = open('data/libc-function-index.txt', 'r')
    funclines = fipfunc.readlines()
    fipfunc.close()
    
    counter = 0
    func_list = []
    
    for idx, fline in enumerate(funclines):
        fline = fline.replace('\t','').replace('\n','')
        if fline.startswith('|'):
            tokens = fline.split('|')   # The function names are |funcname|
            funcname = tokens[1]
            func_list.append(funcname)
            counter += 1
            
            
    print("Found {:d} function definitions for libc api.".format(counter))
    
    fop = open('data/elf-libc-api.txt', 'w')
    
    for func_name in func_list:
        fop.write(func_name + "\n")
        
    fop.close()
    
    return func_list


def generate_libc_var():
    # Extract libc function and variable names from GNU Libc Documentation.
    # Put in feature_extraction.py

    fipvar = open('data/libc-variable-index.txt', 'r')
    varlines = fipvar.readlines()
    fipvar.close()
    
    counter = 0
    var_list = []
    
    for idx, vline in enumerate(varlines):
        vline = vline.replace('\t','').replace('\n','')
        if vline.startswith('|'):
            tokens = vline.split('|')   # The function names are |funcname|
            varname = tokens[1]
            var_list.append(varname)
            counter += 1
            
            
    print("Found {:d} variable definitions for libc api.".format(counter))
    
    fop = open('data/elf-libc-var.txt', 'w')
    
    for var_name in var_list:
        fop.write(var_name + "\n")
        
    fop.close()
    
    return var_list
    

def generate_html_tokens(file_list):
    # Parse a bunch of malicious Javascript/HTML files and extract all the keywords.

    return


def generate_pdf_tokens(file_list):
    # Parse a bunch of malicious PDF files and extract all the keywords.
    # Use peepdf to generate reports for each file in the file list.

    return


def generate_elf_header_tokens(file_list):
    # Parse a bunch of ELF header files generated by objdump
    # and extract section names etc.
    
    return


def generate_pe_header_tokens(file_list):
    # Parse a bund of PE header files generated by objdump
    # and extract section names, import DLLs etc.
    
    return


def generate_x86_asm_tokens(file_list):
    # Parse a bunch of assembler files and extract the
    # instruction set keywords.
    # Actually, could do this by parsing the Intel x86 reference docs.
    
    return


def generate_amd64_asm_tokens(file_list):
    # Parse a bunch of assembler files and extract the
    # instruction set keywords.
    
    return


def rename_header_files(ext_dir):
    # Rename all the PE headers files so it is easier to process them.
    
    file_list = os.listdir(ext_dir)
    counter = 0
    
    for fname in file_list:
        if fname.startswith('Virus'):
            file_path = ext_dir + fname
            trunc_name = fname[0:fname.find('.txt')]
            new_path = ext_dir + trunc_name + '.pe.txt'
            result = sub.check_call(['mv', file_path, new_path])
            counter += 1

        if (counter % 1000) == 0:
            print('Renamed {:d} header files.'.format(counter))

    print('Completed move of {:d} header files.'.format(counter))
    
    return

# Start of script.

# TODO: everything

#start_packer_id_generation_threads()

# TEMP filename fix for PE header files.
ext_dir = '/opt/vs/train1hdr/'
rename_header_files(ext_dir)
ext_dir = '/opt/vs/train2hdr/'
rename_header_files(ext_dir)
ext_dir = '/opt/vs/train3hdr/'
rename_header_files(ext_dir)
ext_dir = '/opt/vs/train4hdr/'
rename_header_files(ext_dir)

# End of script.

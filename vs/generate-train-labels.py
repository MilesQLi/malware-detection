# Generate training labels from ClamAV and Windows Defender reports. For each malware type
# a unique scalar value is generated as a training label, the malware family type is then
# determined by removing version numbers/names from the malware definition and generating
# a unique scalar value for each malware family.
#
# Inputs : sorted-av-report.csv (generated by combine-av-reports.py)
#          row format = [file_name, clamav_malware_type, windefender_malware_type]
#
# Outputs: sorted-family-train-labels.csv
#          row format = [file_name, malware_type, malware_label, family_type, family_label] 
#
#          Also creates the following malware label and count files:
#
#          malware-family-counts.csv (temp file)
#          malware-family-labels.csv (temp file)
#          malware-class-counts.csv  (temp file)
#          malware-class-labels.csv  (temp file)
#
#          malware-family-wd.csv 
#          row format = [malware_family_name, label, count]
#
#          malware-class-wd.csv
#          row format = [malware_class_name, label, count]
#
# Author: Derek Chadwick
# Date  : 30/07/2016

from multiprocessing import Pool
import os
from csv import writer
import numpy as np
import pandas as pd
import math
import scipy.misc
import array
import time as tm
import io # this is required as a compatability layer between 2.x and 3.x because 2.x cannot read utf-16 text files.
import re


def save_family_counts(family_counter_map):
    # Output the malware family counts.
    fop = open('data/malware-family-counts-wd.csv', 'w')
    csv_wouter = writer(fop)
    cols = ['malware_type','count'] # write out the column names.
    csv_wouter.writerow(cols)
    outlines = []
    sorted_keys = family_counter_map.keys()
    sorted_keys.sort()
    for key in sorted_keys:
        outlines.append([key, family_counter_map[key]])
        if (idx % 100) == 0: # write out some lines
            csv_wouter.writerows(outlines)
            outlines = []
            print("Processed family {:s} -> {:d}.".format(key, val))

    # Finish off.
    if (len(outlines) > 0):
        csv_wouter.writerows(outlines)
        outlines = []

    print("Completed processing {:d} families.".format(len(sorted_keys)))    
    fop.close()

    return


def save_sample_counts(sample_counter_map):
    # Output the malware sample classification counts.
    fop = open('data/malware-class-counts-wd.csv', 'w')
    csv_wouter = writer(fop)
    cols = ['malware_type','count'] # write out the column names.
    csv_wouter.writerow(cols)
    outlines = []
    sorted_keys = sample_counter_map.keys()
    sorted_keys.sort()
    for key in sorted_keys:
        outlines.append([key, sample_counter_map[key]])
        if (idx % 100) == 0: # write out some lines
            csv_wouter.writerows(outlines)
            outlines = []
            print("Processed sample {:s} -> {:d}.".format(key, val))

    # Finish off.
    if (len(outlines) > 0):
        csv_wouter.writerows(outlines)
        outlines = []

    print("Completed processing {:d} samples.".format(len(sorted_keys)))    
    fop.close()

    return


def save_family_labels(family_label_map):
    # Output the malware family scalar classifications.
    fop = open('data/malware-family-labels-wd.csv', 'w')
    csv_wouter = writer(fop)
    cols = ['malware_type','class'] # write out the column names.
    csv_wouter.writerow(cols)
    outlines = []
    sorted_keys = family_label_map.keys()
    sorted_keys.sort()
    for key in sorted_keys:
        outlines.append([key, family_label_map[key]])
        if (idx % 100) == 0: # write out some lines
            csv_wouter.writerows(outlines)
            outlines = []
            print("Processed family label {:s} -> {:d}.".format(key, val))

    # Finish off.
    if (len(outlines) > 0):
        csv_wouter.writerows(outlines)
        outlines = []

    print("Completed processing {:d} family labels.".format(len(sorted_keys)))    
    fop.close()

    return


def save_sample_labels(scalar_label_map):
    # Output the malware sample scalar classifications.
    fop = open('data/malware-class-labels-wd.csv', 'w')
    csv_wouter = writer(fop)
    cols = ['malware_type','class'] # write out the column names.
    csv_wouter.writerow(cols)
    outlines = []
    sorted_keys = scalar_label_map.keys()
    sorted_keys.sort()
    for key in sorted_keys:
        outlines.append([key, scalar_label_map[key]])
        if (idx % 100) == 0: # write out some lines
            csv_wouter.writerows(outlines)
            outlines = []
            print("Processed label {:s} -> {:d}.".format(key, val))

    # Finish off.
    if (len(outlines) > 0):
        csv_wouter.writerows(outlines)
        outlines = []

    print("Completed processing {:d} labels.".format(counter))    
    fop.close()

    return


def generate_sample_labels():
    mals = pd.read_csv('data/sorted-av-report.csv')
    # Now generate unique scalar label map, we will use WinDefender as the default classification, if WinDefender is OK
    # and ClamAV is not OK, then use the ClamAV classification, if both are OK then default to 0 label value for now.
    type_x = np.array(mals['malware_type_x'])
    type_y = np.array(mals['malware_type_y'])
    scalar_labels = [0] * mals.shape[0]
    scalar_label_map = {}
    counter = 0
    scalar_label_map['OK'] = 0

    for idx, y_val in enumerate(type_y):
        if y_val != 'OK':
            mals.iloc[idx,1] = mals.iloc[idx,2] # copy the defender classification to ClamAV classification

        # now add the classification to the label map with a new scalar value
        if mals.iloc[idx,1] not in scalar_label_map.keys():
            counter += 1
            scalar_label_map[mals.iloc[idx,1]] = counter

        # now get the scalar label for this malware sample
        scalar_labels[idx] = scalar_label_map[mals.iloc[idx,1]]

    mals['sample_label'] = scalar_labels

    mals.to_csv('data/sorted-av-report-labels-wd.csv', index=False)

    save_sample_labels(scalar_label_map)
    
    return



def generate_family_labels():
    # Now generate unique scalar label map for malware families.
    mals = pd.read_csv('data/sorted-av-report-labels-wd.csv')
    type_x = np.array(mals['malware_type_x'])
    #type_y = mals['malware_type_y']
    family_scalar_labels = [0] * mals.shape[0]
    family_labels = [' '] * mals.shape[0]
    family_label_map = {}
    sample_counter_map = {}
    family_counter_map = {}
    counter = 0
    pwd1 = re.compile('(\w+):(\w+)/(\w+)[!.-/]+(\w+)') # Windows Defender malware definition patterns.
    pwd2 = re.compile('(\w+):(\w+)/(\w+)')
    pcav = re.compile('(\w+)\.(\w+)\.(\w+)[!./-](\w+)') # ClamAV malware definition pattern.
    malware_family = 'unknown'
    family_label_map['unknown'] = 0 # The default family scalar label.

    for idx, x_val in enumerate(type_x):
        # first count the sample type
        if x_val in sample_counter_map.keys():
            sample_counter_map[x_val] += 1
        else:
            sample_counter_map[x_val] = 1

        if x_val != 'OK':
            # if it is a defender classification then convert to ClamAV definition style.
            m = pwd1.match(x_val)
            if m != None:
                malware_family = m.group(2) + '.' + m.group(1) + '.' + m.group(3) # rearrange the components to
            else:                                                                 # (platform).(class).(type)
                m = pwd2.match(x_val)
                if m != None:
                    malware_family = m.group(2) + '.' + m.group(1) + '.' + m.group(3) 
                else:
                    # then check if it is a ClamAV definition.
                    m = pcav.match(x_val)
                    if m != None:        # just truncate the end bit off.
                        malware_family = m.group(1) + '.' + m.group(2) + '.' + m.group(3)
                    else:
                        malware_family = x_val  # catch the corner cases and default to original name/definition.

        else:
            malware_family = 'unknown' # leave the scalar label == 0, the malware sample has not been classified.

        # now add the classification to the label map with a new scalar value
        if malware_family not in family_label_map.keys():
            counter += 1
            family_label_map[malware_family] = counter

        # Count the malware family occurrences.
        if (malware_family in family_counter_map.keys()):
            family_counter_map[malware_family] += 1
        else:
            family_counter_map[malware_family] = 1

        # now get the scalar label for this malware sample
        family_scalar_labels[idx] = family_label_map[malware_family]
        family_labels[idx] = malware_family

        if (idx % 1000) == 0: # report progress
            print("Processed family label {:s} -> {:d}.".format(malware_family, family_label_map[malware_family]))

    # Finish off by adding malware family label to training label set.
    mals['family_label'] = family_scalar_labels
    mals['family_label_str'] = family_labels
    mals.head(20)

    mals.to_csv('data/sorted-family-train-labels-wd.csv', index=False)

    save_family_labels(family_label_map)
    save_sample_counts(sample_counter_map)
    save_family_counts(family_counter_map)

    return




# Start of script.

#TODO: parse command line options for input/output file names.

generate_sample_labels()
generate_family_labels()

# Join the malware family sample scalar classifications and counts.
cldf = pd.read_csv('data/malware-family-labels-wd.csv')
ccdf = pd.read_csv('data/malware-family-counts-wd.csv')
cjdf = pd.merge(cldf,ccdf,on='malware_type')
cjdf.to_csv('data/malware-family-wd.csv', index=False)

# Join the malware sample scalar classifications and counts.
cldf = pd.read_csv('data/malware-class-labels-wd.csv')
ccdf = pd.read_csv('data/malware-class-counts-wd.csv')
cjdf = pd.merge(cldf,ccdf,on='malware_type')
cjdf.to_csv('data/malware-class-wd.csv', index=False)

# End of Script

















# feature_extraction_elf_asm.py
#
# Read a list of ELF ASM and section header files generated by objdump and extract
# feature sets from them.
#
# Input:
#
# Output:
#
# Author: Derek Chadwick
# Date  : 05/09/2016
#
# TODO: all of the things

from multiprocessing import Pool
import os
from csv import writer
import numpy as np
import pandas as pd
import math
import scipy.misc
import array
import time as tm
import re
import subprocess as sub


known_sections = [ '.interp',   
'.note.gnu.build-id',
'.hash',
'.gnu.hash',
'.dynsym',
'.dynstr',
'.gnu.version',
'.gnu.version_r',
'.rel.dyn',
'.rel.plt',
'.init',
'.plt',
'.text',
'.fini',
'.rodata',
'.eh_frame_hdr',
'.eh_frame',
'.gcc_except_table',
'.ctors',
'.dtors',
'.jcr',
'.data.rel.ro',
'.dynamic',
'.got',
'.data',
'.bss',
'.comment' ]

x86_registers = ['edx','esi','es','fs','ds','ss','gs','cs','ah','al',
                 'ax','bh','bl','bx','ch','cl','cx','dh','dl','dx',
                 'eax','ebp','ebx','ecx','edi','esp']

x86_opcodes = ['add','al','bt','call','cdq','cld','cli','cmc','cmp','const','cwd','daa','db'
                ,'dd','dec','dw','endp','ends','faddp','fchs','fdiv','fdivp','fdivr','fild'
                ,'fistp','fld','fstcw','fstcwimul','fstp','fword','fxch','imul','in','inc'
                ,'ins','int','jb','je','jg','jge','jl','jmp','jnb','jno','jnz','jo','jz'
                ,'lea','loope','mov','movzx','mul','near','neg','not','or','out','outs'
                ,'pop','popf','proc','push','pushf','rcl','rcr','rdtsc','rep','ret','retn'
                ,'rol','ror','sal','sar','sbb','scas','setb','setle','setnle','setnz'
                ,'setz','shl','shld','shr','sidt','stc','std','sti','stos','sub','test'
                ,'wait','xchg','xor']

amd64_registers = ['rax','rbx','rcx','rdx','rsp','']

amd64_opcodes = ['aaa','aad','aam','aas','adc','add','and','andn','bextr','bextr','blcfill','blci','blcic','blcmsk','blcs','blsfill',
    'blsi','blsic','blsmsk','blsr','bound','bsf','bsr','bswap','bt','btc','btr','bts','bzhi','call','cbw','cwde','cdqe','cwd','cdq',
    'cqo','clc','cld','clflush','cmc','cmov','cmp','cmps','cmpsb','cmpsw','cmpsd','cmpsq','cmpxchg','cmpxchg8b','cmpxchg16b','cpuid',
    'crc32','daa','das','dec','div','enter','idiv','imul','in','inc','ins','insb','insw','insd','int','into','jcxz','jecxz','jrcxz',
    'jmp','lahf','lds','les','lfs','lgs','lss','lea','leave','lfence','llwpcb','lods','lodsb','lodsw','lodsd','lodsq','loop','loope',
    'loopne','loopnz','loopz','lwpins','lwpval','lzcnt','mfence','mov','movbe','movd','movmskpd','movmskps','movnti','movs','movsb',
    'movsw','movsd','movsq','movsx','movsxd','movzx','mul','mulx','neg','nop','not','or','out','outs','outsb','outsw','outsd','pause',
    'pdep','pext','pop','popa','popad','popcnt','popf','popfd','popfq','prefetch','prefetchw','prefetch','push','pusha','pushad','pushf',
    'pushfd','pushfq','rcl','rcr','rdfsbase','rdgsbase','rdrand','ret','rol','ror','rorx','sahf','sal','shl','sar','sarx','sbb','scas',
    'scasb','scasw','scasd','scasq','set','sfence','shl','shld','shlx','shr','shrd','shrx','slwpcb','stc','std','stos','stosb','stosw',
    'stosd','stosq','sub','t1mskc','test','tzcnt','tzmsk','wrfsbase','wrgsbase','xadd','xchg','xlat','xlatb','xor','arpl','clgi','cli',
    'clts','hlt','int','invd','invlpg','invlpga','iret','iretd','iretq','lar','lgdt','lidt','lldt','lmsw','lsl','ltr','monitor',
    'monitorx','mwait','mwaitx','rdmsr','rdpmc','rdtsc','rdtscp','rsm','sgdt','sidt','skinit','sldt','smsw','sti','stgi','str',
    'swapgs','syscall','sysenter','sysexit','sysret','ud2','verr','verw','vmload','vmmcall','vmrun','vmsave','wbinvd','wrmsr']

MIPS_registers = []

MIPS_opcodes = []

SPARC_registers = []

SPARC_opcodes = []

ARM_registers = ['r0','r1','r2','r3','r4','r5','r6','r7','r8','r9','r10','r11','r12','r13','r14','r15','cpsr']

ARM_opcodes = ['adc','msr','add','mul','and','mvn','b','orr','bic','rsb','bl','rsc','bx','sbc','cdp','smlal','cmn','smull',
               'cmp','stc','eor','stm','ldc','str','ldm','strb','ldr','strbt','ldrb','strh','ldrbt','strt','ldrh','sub','ldrsb','swi',
               'ldrsh','swp','ldrt','swpb','mcr','teq','mla','tst','mov','umlal','mrc','umull','mrs']

Motorola_registers = []

Motorola_opcodes = []

PowerPC_registers = []

PowerPC_opcodes = []


def count_asm_symbols(asm_code):
    symbols = [0]*7
    for row in asm_code:
        if '*' in row:
            symbols[0] += 1
        if '-' in row:
            symbols[1] += 1
        if '+' in row:
            symbols[2] += 1
        if '[' in row:
            symbols[3] += 1
        if ']' in row:
            symbols[4] += 1
        if '@' in row:
            symbols[5] += 1
        if '?' in row:
            symbols[6] += 1

    return symbols


def count_asm_registers(asm_code):
    registers_values = [0]*len(registers)
    for row in asm_code:
        parts = row.replace(',',' ').replace('+',' ').replace('*',' ').replace('[',' ').replace(']',' ') \
                    .replace('-',' ').split()
        for register in registers:
            registers_values[registers.index(register)] += parts.count(register)
    return registers_values


def count_asm_opcodes(asm_code):
    opcodes_values = [0]*len(opcodes)
    for row in asm_code:
        parts = row.split()

        for opcode in opcodes:
            if opcode in parts:
                opcodes_values[opcodes.index(opcode)] += 1
                break
    return opcodes_values


def count_asm_APIs(asm_code, apis):
    apis_values = [0]*len(apis)
    for row in asm_code:
        for i in range(len(apis)):
            if apis[i] in row:
                apis_values[i] += 1
                break
    return apis_values


def count_asm_misc(asm_code):
    keywords_values = [0]*len(keywords)
    for row in asm_code:
        for i in range(len(keywords)):
            if keywords[i] in row:
                keywords_values[i] += 1
                break
    return keywords_values


# Extract features from test/training asm files, file list is passed in as a parameter

def extract_asm_features(tfiles, feature_file, api_file):
    
    pid = os.getpid()
    print('Process id:', pid)
    feature_file = 'data/' + str(pid) + feature_file # libc API, symbols, registers, opcodes, etc...   
    print('feature file:', feature_file)

    fapi = open("data/elf-libc-api.txt")
    defined_apis = fapi.readlines()
    for idx, fname in defined_apis:
        defined_apis[idx] = fname.rstrip() # Remove newlines, they are annoying.

    asm_files = [i for i in tfiles if '.asm' in i]
    ftot = len(asm_files)
    
    feature_counts = []
    with open(feature_file, 'w') as f:
        # write the csv header
        fw = writer(f)
        colnames = ['file_name'] + registers + opcodes + defined_apis + keywords
        fw.writerow(colnames)
        
        for idx, fname in enumerate(asm_files):
            fasm = open(ext_drive + fname, 'r')
            content = fasm.readlines()
            
            reg_vals = count_asm_registers(content)
            opc_vals = count_asm_opcodes(content)
            api_vals = count_asm_APIs(content, defined_apis)
            sec_vals = count_asm_sections(content)
            mis_vals = count_asm_misc(content)
            count_vals = reg_vals + opc_vals + api_vals + mis_vals + sec_vals
            
            feature_counts.append([fname[:fname.find('.asm')]] + count_vals)   
            
            # Writing rows after every 10 files processed
            if (idx+1) % 10 == 0:
                print("{:d} Processed {:d} of {:d} total files.".format(pid, idx + 1, ftot))
                fw.writerows(feature_counts)
                feature_counts = []
                
        # Writing remaining files
        if len(feature_counts) > 0:
            fw.writerows(feature_counts)
            feature_counts = []

    return


def sort_and_save_asm_feature_file():
    entropys = pd.read_csv('data/elf-asm-features.csv')
    # DataFrame.sort() is deprecated, but this is an old version of pandas, does not have sort_values().
    sorted_entropys = entropys.sort('file_name')
    sorted_entropys.to_csv('data/sorted-elf-asm-features.csv', index=False)
    sorted_entropys.head(20)
    
    return


def combine_asm_files():
    # Function to combine the newly generated asm feature files into one file:
    # 1. list data directory
    # 2. For each file in file list that matches (\d\d\d\d-asm-features.csv)
    # 3. Trim the filenames if necessary (should remove VirusShare_  prefix).
    # 4. Concatenate the unsorted asm feature files.
    # 5. Sort and write to data/sorted-asm-features.csv
    fop = open('data/elf-asm-features.csv','w')
    #fop.write('file_name,entropy,file_size\n')
    p1 = re.compile('\d{3,5}-elf-asm-features.csv') # This is the PID prefix for each file.
    file_list = os.listdir('data/')
    counter = 0
    for file_name in file_list:
        if p1.match(file_name):
            fip = open('data/' + file_name, 'r')
            in_lines = fip.readlines()
            fop.writelines(in_lines)
            counter += len(in_lines)
            fip.close()
            
    print('Completed combine of {:d} asm features.'.format(counter))  
    
    fop.close()
    
    sort_and_save_asm_feature_file()
    
    return

# Start of Script

# Divide the train files into four groups for multiprocessing.

# TODO: add command line arguments to specify file names.

ext_drive = '/opt/vs/train1/'
tfiles = os.listdir(ext_drive)
print("Total Files: {:d}".format(len(tfiles)))

extract_asm_features(tfiles)

#quart = len(tfiles)/4
#train1 = tfiles[:quart]
#train2 = tfiles[quart:(2*quart)]
#train3 = tfiles[(2*quart):(3*quart)]
#train4 = tfiles[(3*quart):]
#print("Files: {:d} - {:d} - {:d}".format(len(tfiles), quart, (len(train1)+len(train2)+len(train3)+len(train4))))
#trains = [train1, train2, train3, train4]

#p = Pool(4)
#p.map(extract_asm_features, trains)

#combine_asm_files()


# End of Script
    

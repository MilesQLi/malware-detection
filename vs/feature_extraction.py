# Run all the feature extraction functions:
#    1. Generate packer id values for PE files.
#    2. Generate file id values for all files.
#    3. Calculate entropy and file size for all files.
#    4. Disassemble upacked PE files.
#    5. Generate PE header information.
#    6. Extract ASM feature set.
#    7. Generate call graphs.
#    8. Calculate sample statistics.
#
#
# Author: Derek Chadwick
# Date  : 04/08/2016



from multiprocessing import Pool
import os
import peutils
import pefile
import sys
import re


# Local modules
import feature_extraction_packer_id as fepi
import feature_extraction_file_id as fefi
import feature_extraction_entropy as feet
import feature_extraction_elf_asm as felf
import feature_extraction_pe_asm as fasm



def generate_libc_api():
    # Extract libc function and variable names from GNU Libc Documentation.
    # Put in feature_extraction.py
    
    fipfunc = open('data/libc-function-index.txt', 'r')
    funclines = fipfunc.readlines()
    fipfunc.close()
    
    counter = 0
    func_list = []
    
    for idx, fline in enumerate(funclines):
        fline = fline.replace('\t','').replace('\n','')
        if fline.startswith('|'):
            tokens = fline.split('|')   # The function names are |funcname|
            funcname = tokens[1]
            func_list.append(funcname)
            counter += 1
            
            
    print("Found {:d} function definitions for libc api.".format(counter))
    
    fop = open('data/elf-libc-api.txt', 'w')
    
    for func_name in func_list:
        fop.write(func_name + "\n")
        
    fop.close()
    
    return func_list


def generate_libc_var():
    # Extract libc function and variable names from GNU Libc Documentation.
    # Put in feature_extraction.py

    fipvar = open('data/libc-variable-index.txt', 'r')
    varlines = fipvar.readlines()
    fipvar.close()
    
    counter = 0
    var_list = []
    
    for idx, vline in enumerate(varlines):
        vline = vline.replace('\t','').replace('\n','')
        if vline.startswith('|'):
            tokens = vline.split('|')   # The function names are |funcname|
            varname = tokens[1]
            var_list.append(varname)
            counter += 1
            
            
    print("Found {:d} variable definitions for libc api.".format(counter))
    
    fop = open('data/elf-libc-var.txt', 'w')
    
    for var_name in var_list:
        fop.write(var_name + "\n")
        
    fop.close()
    
    return var_list
    

def generate_html_tokens(file_list):
    # Parse a bunch of malicious Javascript/HTML files and extract all the keywords.

    return


def generate_pdf_tokens(file_list):
    # Parse a bunch of malicious PDF files and extract all the keywords.
    # Use peepdf to generate reports for each file in the file list.

    return


def generate_elf_header_tokens(file_list):
    # Parse a bunch of ELF header files generated by objdump
    # and extract section names etc.
    
    return


def generate_pe_header_tokens(file_list):
    # Parse a bund of PE header files generated by objdump
    # and extract section names, import DLLs etc.
    
    return


def generate_x86_asm_tokens(file_list):
    # Parse a bunch of assembler files and extract the
    # instruction set keywords.
    # Actually, could do this by parsing the Intel x86 reference docs.
    
    return


def generate_amd64_asm_tokens(file_list):
    # Parse a bunch of assembler files and extract the
    # instruction set keywords.
    
    return


# Start of script.

# TODO: everything

#start_packer_id_generation_threads()


# End of script.
